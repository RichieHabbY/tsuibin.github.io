<!DOCTYPE html>
<html>
  <head>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="">
    <meta name="author" content="">
    
    <title>Uliweb Zone - 教程 - 一步一步学内核(Linux kernel) - 下半部的机制</title>
    <!-- toplinks -->
<script type="text/javascript" src="/static/jquery/jquery-1.7.2.min.js?ver=2"></script>
<script type="text/javascript" src="/static/jsutils/json2.js?ver=2"></script>
<!--[if lt IE 9]>
<script type="text/javascript" src="/static/bootstrap/asset/html5.js?ver=2"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="/static/bootstrap/2.2.0/bootstrap.min.css?ver=2"/>
<script type="text/javascript" src="/static/bootstrap/2.2.0/js/bootstrap.min.js?ver=2"></script>
<link rel="stylesheet" type="text/css" href="/static/bootstrap_extend.css?ver=2"/>
<link rel="stylesheet" type="text/css" href="/static/jquery/ui/css/redmond/jquery-ui-1.8.16.custom.css?ver=2"/>
<link rel="stylesheet" type="text/css" href="/static/pnotify/1.2.0/jquery.pnotify.default.css?ver=2"/>
<link rel="stylesheet" type="text/css" href="/static/pnotify/1.2.0/jquery.pnotify.default.icons.css?ver=2"/>
<script type="text/javascript" src="/static/pnotify/1.2.0/jquery.pnotify.min.js?ver=2"></script>
<link rel="stylesheet" type="text/css" href="/static/bootheme/bootheme.css?ver=2"/>
<link rel="stylesheet" type="text/css" href="/static/tutorials/tutorials.css?ver=2"/>
<link rel="stylesheet" type="text/css" href="/static/poshytip/tip-twitter/tip-twitter.css?ver=2"/>
<link rel="stylesheet" type="text/css" href="/static/poshytip/tip-yellow/tip-yellow.css?ver=2"/>
<link rel="stylesheet" type="text/css" href="/static/poshytip/tip-yellowsimple/tip-yellowsimple.css?ver=2"/>
<script type="text/javascript" src="/static/poshytip/jquery.poshytip.js?ver=2"></script>
<script type="text/javascript" src="/static/jquery/ui/js/jquery-ui-1.8.16.custom.min.js?ver=2"></script>
<script type="text/javascript" src="/static/jquery/ui/js/jquery.ui.datepicker.zh.js?ver=2"></script>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/asset/prettify.css?ver=2"/>
<script type="text/javascript" src="/static/bootstrap/asset/prettify.js?ver=2"></script>
<link rel="stylesheet" type="text/css" href="/static/pageslide/jquery.pageslide.css?ver=2"/>
<script type="text/javascript" src="/static/jqutils/jquery.form.js?ver=2"></script>
<link rel="stylesheet" type="text/css" href="/static/jqutils/jqutils.css?ver=2"/>
<script type="text/javascript" src="/static/jqutils/jqrselect.js?ver=2"></script>
<script type="text/javascript" src="/static/jqutils/jqutils.js?ver=2"></script>
<link rel="stylesheet" type="text/css" href="/static/toc/toc.css?ver=2"/>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/fontawesome/css/font-awesome.css?ver=2"/>
<!--[if IE 7]>
  <link rel="stylesheet" href="/static/bootstrap/fontawesome/css/font-awesome-ie7.css">
<![endif]-->

<script type="text/javascript" src="/static/tutorials/comment.js?ver=2"></script>
<link rel="stylesheet" type="text/css" href="/static/jqutils/ui.totop.css?ver=2"/>
<script type="text/javascript" src="/static/jqutils/jquery.ui.totop.js?ver=2"></script>
<script type="text/javascript" src="/static/jqutils/jquery.hotkeys.js?ver=2"></script>
    
    
  </head>

<body class="bootstrap-body">









<script type="text/javascript">
$.extend($.pnotify.defaults, {"styling":"bootstrap"});
var show_message = function(message, category){
    $.pnotify({
        //pnotify_title: 'Regular Notice',
        pnotify_history: false,
        pnotify_text: message,
        pnotify_type: category || 'success',
        pnotify_animation: 'fade',
        pnotify_before_open: function(pnotify){
           // Position this notice in the center of the screen.
           pnotify.css({
               "top": 1,
               "left": ($(top.window).width() / 2) - (pnotify.width() / 2)
           });
        }
    });
}

$(function(){
    
});
</script>


<script>
// using jQuery
function getCookie(name) {
    var cookieValue = null;
    if (document.cookie && document.cookie != '') {
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookie = jQuery.trim(cookies[i]);
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) == (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

function csrfSafeMethod(method) {
    // these HTTP methods do not require CSRF protection
    return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
}
$.ajaxSetup({
    crossDomain: false, // obviates need for sameOrigin test
    beforeSend: function(xhr, settings) {
        if (!csrfSafeMethod(settings.type)) {
            xhr.setRequestHeader("X-CSRFToken", getCookie('_csrf_token'));
        }
    }
});
</script>




<div class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container-fluid">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <a class="brand" href="#">Uliweb Zone</a>
      <div class="nav-collapse">
        
<ul class="nav">
    
<li><a href="/"><span>Home</span></a></li><li><a href="/forum"><span>Forum</span></a></li><li class="active"><a href="/tutorial"><span>Tutorial</span></a></li><li><a href="/class"><span>Class</span></a></li><li><a href="/user/view"><span>Admin</span></a></li><li><a href="/about"><span>About</span></a></li>



</ul>

      
<style>
#userinfo.btn-toolbar {margin-top:0;margin-bottom:0;font-size:14px;}
#userinfo.btn-toolbar a{vertical-align:middle;}
#userinfo img {
-webkit-border-radius: 3px;
   -moz-border-radius: 3px;
        border-radius: 3px;
}
#userinfo [class^="icon-"], #userinfo [class*=" icon-"], #userinfo [class^="icon-"]:hover, #userinfo [class*=" icon-"]:hover{
    vertical-align:middle;
    margin-bottom:3px;
}
</style>
    

    
        <p class="pull-right user_info">
            <a href="/login">登录</a> | <a href="/register">注册</a>
        </p>
    

    
        
    

      </div><!--/.nav-collapse -->
    </div>
  </div>
</div>

    















<style>
#pageslide {
width:320px;
}
#toc {width:22%;}
/* scrollbar  */
.nano .content      { padding: 10px; }
.nano .pane         { background: #999; }
.nano .pane .slider { background: #111; }

</style>
<div class="container-fluid">
    <div class="row-fluid">
        <div class="span12">
            <ul class="breadcrumb">
              <li>
                <a href="/tutorial">返回</a> <span class="divider">/</span>
              </li>
              <li>
                <a href="/tutorial/read/11.html">一步一步学内核(Linux kernel)</a> <span class="divider">/</span>
              </li>
              <li class="active">
                下半部的机制
              </li>
            </ul>
        </div>
    </div>
    <div class="row-fluid">
        <div class="span9" id="article">
            <!-- Prompt IE 6 users to install Chrome Frame. Remove this if you support IE 6.
      chromium.org/developers/how-tos/chrome-frame-getting-started -->
 <!--[if lt IE 8]><div class="alert alert-info">Your browser is <em>ancient!</em> <a href="http://browsehappy.com/">Upgrade to a different browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to experience this site.</div><![endif]-->

            <div class="outter">
                <div class="chapter-prev chapter-top animated">
                    <a prev-chapter href="/tutorial/view_chapter/82.html"><i class="icon-arrow-left"></i> 2.7 内核模块之中断</a>
                </div>
                <div class="chapter-next chapter-top animated">
                    <a next-chapter href="/tutorial/view_chapter/83.html">2.9 内核模块之定时器 <i class="icon-arrow-right"></i></a>
                </div>
                <div class="expander">&raquo;</div>
                <div class="content-inner rounded_bottom article">
                    <h1>下半部的机制</h1>
                    <div style="margin-top:-10px;margin-bottom:20px;">
                        <!-- 评论 <a id="global-comment-count" href="/tutorial/view_paragraph_comments/109?para=0" class="para-comments-count active right animated">0</a> -->
                            <span class="gray">valley 于 2012-09-20 01:26:22+00:00 更新</span>
                            <span class="label label-info">访问次数：444</span>
                        
                    </div>
                    
                    
                
                    <blockquote><p>在前面的上一节中，我们初步了解了中断的相关知识，现在看下我们常说的上半部与下半部的机制吧。。。</p>
<p>Linux中断分为两个半部：上半部（tophalf）和下半部(bottom half)。</p>
<p>上半部的功能是"登记中断"，当一个中断发生时，它进行相应地硬件读写后就把中断例程的下半部挂到该设备的下半部执行队列中去。</p>
<p>因此，上半部 执行的速度就会很快，可以服务更多的中断请求。</p>
<p>但是，仅有"登记中断"是远远不够的，因为中断的事件可能很复杂。</p>
<p>因此，Linux引入了一个下半部，来完 成中断事件的绝大多数使命。</p>
<p>下半部和上半部最大的不同是下半部是可中断的，而上半部是不可中断的，</p>
<p>下半部几乎做了中断处理程序所有的事情，而且可以被新的 中断打断！下半部则相对来说并不是非常紧急的，</p>
<p>通常还是比较耗时的，因此由系统自行安排运行时机，不在中断服务上下文中执行。</p>
<p>Linux实现下半部的机制主要有tasklet和工作队列。</p>
<p>具体的使用方法和原理我们将下两节中来完成。。。</p>
</blockquote>
<blockquote><h3 id="title_0.0.1">tasklet机制 </h3>
</blockquote>
<blockquote><p>tasklet机制是一种推迟执行的机制.</p>
<p>1.数据结构为tasklet<em>struct</p>
</blockquote>
<pre class="prettyprint linenums pre-scrollable"><code>/* Tasklets --- multithreaded analogue of BHs.

   Main feature differing them of generic softirqs: tasklet
   is running only on one CPU simultaneously.

   Main feature differing them of BHs: different tasklets
   may be run simultaneously on different CPUs.

   Properties:
   * If tasklet_schedule() is called, then tasklet is guaranteed
     to be executed on some cpu at least once after this.
   * If the tasklet is already scheduled, but its excecution is still not
     started, it will be executed only once.
   * If this tasklet is already running on another CPU (or schedule is called
     from tasklet itself), it is rescheduled for later.
   * Tasklet is strictly serialized wrt itself, but not
     wrt another tasklets. If client needs some intertask synchronization,
     he makes it with spinlocks.
 */

struct tasklet_struct
{
        struct tasklet_struct *next; //指向链表中下一个结构
        unsigned long state;         //状态
        atomic_t count;              //引用计数
        void (*func)(unsigned long);  //要调用的函数
        unsigned long data;  		//传递给函数的参数
};</code></pre>
<blockquote>
<p>结构中的func域就是下半部中要推迟执行的函数 ，data是它唯一的参数。</p>
<p>State域的取值为TASKLET_STATE_SCHED或TASKLET_STATE_RUN。</p>
<p>TASKLET_STATE_SCHED表示小任务已被调度，正准备投入运行，TASKLET_STATE_RUN表示小任务正在运行。</p>
<p>TASKLET_STATE_RUN只有在多处理器系统上才使用，单处理器系统什么时候都清楚一个小任务是不是正在运行</p>
<p>（它要么就是当前正在执行的代码，要么不是）。</p>
<p>Count域是小任务的引用计数器。如果它不为0，则小任务被禁止，不允许执行；只有当它为零，小任务才被激活，</p>
<p>并且在被设置为挂起时，小任务才能够执行。</p>
<p>2.声明和使用tasklet</p>
<p>大多数情况下，为了控制一个寻常的硬件设备，tasklet机制是实现下半部的最佳选择。tasklet可以动态创建，</p>
<p>使用方便，执行起来也比较快。</p>
<p>我们既可以静态地创建tasklet，也可以动态地创建它。</p>
<p>选择那种方式取决于到底是想要对tasklet进行直接引用还是一个间接引用。</p>
<p>如果准备静态地创建一个tasklet（也就是对它直接引用），使用下面两个宏中的一个：</p>
<p>DECLARE_TASKLET(name, func, data)</p>
<p>DECLARE_TASKLET_DISABLED(name, func, data)</p>
<p>这两个宏都能根据给定的名字静态地创建一个tasklet<em>struct结构。</p>
<p>当该tasklet被调度以后，给定的函数func会被执行，它的参数由data给出。</p>
<p>这两个宏之间的区别在于引用计数器的初始值设置不同。第一个宏把创建的tasklet的引用计数器设置为0，</p>
<p>因此，该tasklet处于激活状态。另一个把引用计数器设置为1，所以该tasklet处于禁止状态。例如：</p>
<p>DECLARE_TASKLET(my<em>tasklet, my_tasklet_handler, dev);</p>
<p>这行代码其实等价于</p>
<p>struct tasklet_struct my_tasklet = { NULL, 0, ATOMIC_INIT(0), tasklet_handler, dev};</p>
<p>这样就创建了一个名为my<em>tasklet的小任务，其处理程序为tasklet</em>handler，并且已被激活。</p>
<p>当处理程序被调用的时候，dev就会被传递给它。</p>
<p>3.编写自己的tasklet处理程序</p>
<p>tasklet处理程序必须符合如下的函数类型：</p>
<p>void tasklet_handler(unsigned long data)</p>
<p>由于tasklet不能睡眠，因此不能在tasklet中使用信号量或者其它产生阻塞的函数。</p>
<p>但是tasklet运行时可以响应中断。</p>
<p>4 调度自己的tasklet</p>
<p>通过调用tasklet<em>schedule()函数并传递给它相应的tasklt</em>struct指针，</p>
<p>该tasklet就会被调度以便适当的时候执行：</p>
<p>tasklet_schedule(&amp;my<em>tasklet);  /<em>把 my_tasklet 标记为挂起 </em>/</p>
<p>在tasklet被调度以后，只要有机会它就会尽可能早的运行。在它还没有得到运行机会之前，</p>
<p>如果一个相同的tasklet又被调度了，那么它仍然只会运行一次。</p>
<p>可以调用tasklet<em>disable()函数来禁止某个指定的tasklet。如果该tasklet当前正在执行，</p>
<p>这个函数会等到它执行完毕再返回。调用tasklet<em>enable()函数可以激活一个tasklet，</p>
<p>如果希望把以DECLARE_TASKLET_DISABLED（）创建的tasklet激活，也得调用这个函数，如：</p>
<p>tasklet_disable(&amp;my<em>tasklet);     /<em> tasklet现在被禁止,这个tasklet不能运行 </em>/</p>
<p>tasklet_enable(&amp;my<em>tasklet);    /<em>  tasklet现在被激活 </em>/</p>
<p>也可以调用tasklet<em>kill()函数从挂起的队列中去掉一个tasklet。</p>
<p>该函数的参数是一个指向某个tasklet的tasklet<em>struct的长指针。</p>
<p>在tasklet重新调度它自身的时候，从挂起的队列中移去已调度的tasklet会很有用。</p>
<p>这个函数首先等待该tasklet执行完毕，然后再将它移去。下面是一个示例：</p>
</blockquote>
<pre class="prettyprint linenums pre-scrollable"><code>#include &lt;linux/module.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/kdev_t.h&gt;
#include &lt;linux/cdev.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/interrupt.h&gt;

static struct tasklet_struct my_tasklet;

static void tasklet_handler(unsigned long data)
{
	printk(KERN_ALERT "tasklet_handler is running.\n");
}

static int __init init_tasklet(void)
{
	tasklet_init(&amp;my_tasklet,tasklet_handler,0);
	tasklet_schedule(&amp;my_tasklet);

	return 0;
}

static void __exit exit_tasklet(void)
{
	tasklet_kill(&amp;my_tasklet);
	printk(KERN_ALERT "tasklet_exit running.\n");
}

MODULE_LICENSE("GPL");
module_init(init_tasklet);
module_exit(exit_tasklet);</code></pre>
<pre class="prettyprint linenums pre-scrollable"><code>$ ./mmake tasklet.c 
$ sudo insmod tasklet.ko
$ dmesg</code></pre>
<blockquote>
<p>tasklet_handler is running.</p>
<p>tasklet模型框架：</p>
</blockquote>
<pre class="prettyprint linenums pre-scrollable"><code>    //tasklet使用模板  
    /*定义tasklet和底半部函数相关联*/  
    void xxx_do_tasklet(unsigned long);  
    DECLARE_TASKLET(xxx_tasklet,xxx_do_tasklet,0);  
    /*中断处理底半部*/  
    void xxx_do_tasklet(unsigned long)  
    {  
        ............  
    }  
    /*中断处理顶半部*/  
    irqreturn_t xxx_interrupt(int irq,void *dev_id,struct pt_regs *regs)  
    {  
        .....................  
        /*调度xxx_do_tasklet函数在适当的时候执行。*/  
        tasklet_schedule(&amp;xxx_tasklet);  
        ......................  
    }  
    /*设备驱动模块加载函数*/  
    int __init xxx_init(void)  
    {  
        .................  
        /*申请中断*/  
        result=request_irq(xxx_irq,xxx_interrupt,SA_INTERRUPT,"XX",NULL);  
        ..................  
    }  
    /*设备驱动模块卸载函数*/  
    void __exit xxx_exit(void)  
    {  
        .....................  
        free_irq(xxx_irq,xxx_interrupt);  
        .....................  
    }  
      
    /*软中断和tasklet仍然运行于中断上下文，而工作队列则运行于进程上下文。因此，软中断和tasklet处理函数中不能睡眠，而工作队列处理函数中允许睡眠。 
    local_bh_disable()和local_bh_enbale()是内核中用于禁止和使能 中断和tasklet底半部机制的函数*/</code></pre>
<blockquote>
</blockquote>
<blockquote><h3 id="title_0.0.1">工作队列</h3>
</blockquote>
<blockquote><p>上面我们了解了tasklet，下面我们将继续了解另外一个下半部分实现的方法：工作队列 为什么还需要工作队列？</p>
<p>工作队列（work queue）是另外一种将中断的部分工作推后的一种方式，</p>
<p>它可以实现一些tasklet不能实现的工作，比如工作队列机制可以睡眠。这种差异的本质原因是，</p>
<p>在工作队列机制中，将推后的工作交给一个称之为工作者线程（worker thread）的内核线程去完成</p>
<p>（单核下一般会交给默认的线程events/0）。因此，在该机制中，</p>
<p>当内核在执行中断的剩余工作时就处在进程上下文（process context）中。</p>
<p>也就是说由工作队列所执行的中断代码会表现出进程的一些特性，最典型的就是可以重新调度甚至睡眠。</p>
<p>对于tasklet机制（中断处理程序也是如此），内核在执行时处于中断上下文（interrupt context）中。</p>
<p>而中断上下文与进程毫无瓜葛，所以在中断上下文中就不能睡眠。</p>
<p>因此，选择tasklet还是工作队列来完成下半部分应该不难选择。当推后的那部分中断程序需要睡眠时，</p>
<p>工作队列毫无疑问是你的最佳选择；否则，还是用tasklet吧。</p>
<p>中断上下文</p>
<p>在了解中断上下文时，先来回顾另一个熟悉概念：进程上下文（这个中文翻译真的不是很好理解，</p>
<p>用“环境”比它好很多）。一般的进程运行在用户态，如果这个进程进行了系统调用，</p>
<p>那么此时用户空间中的程序就进入了内核空间，并且称内核代表该进程运行于内核空间中。</p>
<p>由于用户空间和内核空间具有不同的地址映射，并且用户空间的进程要传递很多变量、参数给内核，</p>
<p>内核也要保存用户进程的一些寄存器、变量等，以便系统调用结束后回到用户空间继续执行。</p>
<p>这样就产生了进程上下文。</p>
<p>所谓的进程上下文，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈中的内容。</p>
<p>当内核需要切换到另一个进程时（上下文切换），它需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态继续执行。上述所说的工作队列所要做的工作都交给工作者线程来处理，因此它可以表现出进程的一些特性，比如说可以睡眠等。</p>
<p>对于中断而言，是硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。</p>
<p>过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理，</p>
<p>中断上下文就可以理解为硬件传递过来的这些参数和内核需要保存的一些环境，主要是被中断的进程的环境。</p>
<p>因此处于中断上下文的tasklet不会有睡眠这样的特性。</p>
<p>工作队列的使用</p>
<p>内核中通过下述结构体来表示一个具体的工作：</p>
</blockquote>
<pre class="prettyprint linenums pre-scrollable"><code>	struct work_struct
	{
	    unsigned long pending;//这个工作是否正在等待处理
	    struct list_head entry;//链接所有工作的链表，形成工作队列
	    void (*func)(void *);//处理函数
	    void *data;//传递给处理函数的参数
	    void *wq_data;//内部使用数据
	    struct timer_list timer;//延迟的工作队列所用到的定时器
	};</code></pre>
<blockquote>
<p>而这些工作（结构体）链接成的链表就是所谓的工作队列。工作者线程会在被唤醒时执行链表上的所有工作，当一个工作被执行完毕后，相应的work<em>struct结构体也会被删除。当这个工作链表上没有工作时，工作线程就会休眠。</p>
<p>通过如下宏可以创建一个要推后的完成的工作:</p>
</blockquote>
<pre class="prettyprint linenums pre-scrollable"><code>	DECLARE_WORK(name,void(*func)(void*),void *data);</code></pre>
<blockquote>
<p>也可以通过下述宏动态创建一个工作:</p>
</blockquote>
<pre class="prettyprint linenums pre-scrollable"><code>	INIT_WORK(struct work_struct *work,void(*func)(void*),void *data);</code></pre>
<blockquote>
<p>与tasklet类似，每个工作都有具体的工作队列处理函数，原型如下:</p>
</blockquote>
<pre class="prettyprint linenums pre-scrollable"><code>	void work_handler(void *data)</code></pre>
<blockquote>
<p>将工作队列机制对应到具体的中断程序中，即那些被推后的工作将会在func所指向的那个工作队列处理函数中被执行。</p>
<p>实现了工作队列处理函数后，就需要schedule<em>work函数对这个工作进行调度，就像这样：</p>
</blockquote>
<pre class="prettyprint linenums pre-scrollable"><code>	schedule_work(&amp;work);</code></pre>
<blockquote>
<p>这样work会马上就被调度，一旦工作线程被唤醒，这个工作就会被执行（因为其所在工作队列会被执行）。</p>
<p>下面是一个示例：</p>
</blockquote>
<pre class="prettyprint linenums pre-scrollable"><code>//-------------------------------------------------------------------
//	tryworkq.c
//
//	This module demonstrates the use of a kernel workqueue, as a
//	mechanism for scheduling work to be performed after a delay.
//
//	NOTE: Developed and tested with Linux kernel version 2.6.10.
//
//	programmer: ALLAN CRUSE
//	written on: 20 MAR 2005
//	revised on: 24 OCT 2007 -- for workqueue changes in 2.6.22.5
//-------------------------------------------------------------------

#include &lt;linux/module.h&gt;	// for init_module() 
#include &lt;linux/workqueue.h&gt;	// for create_workqueue()

char modname[] = "tryworkq";

void dowork( struct work_struct * );
DECLARE_DELAYED_WORK( mywork, dowork );
struct workqueue_struct *myqueue;

void dowork( struct work_struct *dummy  )
{
	printk( "\n\n%15s: I am doing the delayed work now\n", modname );
}

int init_module( void )
{
	int	retval;

	printk( "&lt;1&gt;\nInstalling \'%s\' module\n", modname );
	myqueue = create_singlethread_workqueue( "mywork" );
	retval = queue_delayed_work( myqueue, &amp;mywork, HZ*5 );
	printk( "retval=%d\n", retval );
	return	0;  // SUCCESS
}


void cleanup_module( void )
{
	printk( "&lt;1&gt;Removing \'%s\' module\n", modname );
	destroy_workqueue( myqueue );
}

MODULE_LICENSE("GPL");</code></pre>
<blockquote>
</blockquote>
<pre class="prettyprint linenums pre-scrollable"><code>$ ./mmake tryworkq.c
$ sudo insmod tryworkq.ko 
$ dmesg</code></pre>
<blockquote>
<p><img src="http://uliweb.clkg.org/uploads/tutorials/11/5cef18f0ec1211e19ce7f23c91df0780.png"&gt;</p>
<p>工作队列之编程模板：</p>
</blockquote>
<pre class="prettyprint linenums pre-scrollable"><code>//定义工作队列和关联函数

struct work_struct xxx_wq;

void xxx_do_work(unsigned long);

//中断处理底半部

void xxx_do_work(unsigned long)
{
      ………………
}

//中断处理顶半部
irqreturn_t xxx_interrupt( int irq, void * dev_id, struct pt_regs * regs)
{
      …………..
       schedule_work(&amp;xxx_wq);
       ………….
}

//设备驱动模块加载函数
int xxx_int(void)
{
        …………
       result = request_irq(xxx_irq, xxx_interrupt, SA_INTERRUPT, “xxx”, NULL);
//初始化工作队列
        INIT_WORK(&amp;xxx_wq, (void (*) (void *)) xxx_do_work, NULL);
      …………….
}
 
//设备驱动模块卸载函数
void xxx_exit(void)
{
       ……………
       
       free_irq(xxx_irq, xxx_interrupt);
       ………….
}</code></pre>
<blockquote>
<p>下面说下tasklet 与 workqueue的区别？</p>
<p>tastlet是个软中断，workqueue放在内核线程中执行。</p>
<p>软中断比workqueue优先处理，在它两的入口处中断都是使能的。</p>
<p>另外大概2.6.32（记不得确切版本了）以后 IRQ_ONESHOT会创建单独的线程处理中断，</p>
<p>并且在底半部执行完后自己enable中断。</p>
<p>参考文章：</p>
<p><a href="http://edsionte.com/techblog/archives/1582">http://edsionte.com/techblog/archives/1582</a> <a href="http://blog.csdn.net/wq897387/article/details/7495506">http://blog.csdn.net/wq897387/article/details/7495506</a></p>
</blockquote>

                <!-- <hr/>
                    <div id="disqus_thread"></div>
                    <script type="text/javascript">
                       /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
                       var disqus_shortname = 'uliwebzone'; // required: replace example with your forum shortname
            
                       /* * * DON'T EDIT BELOW THIS LINE * * */
                       (function() {
                           var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                           dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                           (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                       })();
                   </script>
                   <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                   <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                -->
                    <div class="tutorial-footer">
                        <p>评论 <a id="global-comment-count" href="/tutorial/view_paragraph_comments/109?para=0" class="para-comments-count active right animated">0</a>
                            <span class="gray">valley 于 2012-09-20 01:26:22+00:00 更新</span>
                        </p>
                    </div>
                    
                    <!-- JiaThis Button BEGIN -->
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?uid=1342595503212835&type=left&amp;btn=l1.gif" charset="utf-8"></script>
<!-- JiaThis Button END -->
<script src="http://mediaplayer.yahoo.com/js"></script>

                
                    <div class="alert alert-info">
                        <a href="#" class="close" data-dismiss="alert">&times;</a>
                        可以使用<i class="icon-arrow-left"></i>和<i class="icon-arrow-right"></i>来跳转到前一章节或后一章节。
                        还可以使用<b>回车</b>来扩展或缩小文章区域。<b>C</b>键打开评论，<b>ESC</b>关闭评论。
                    </div>
                
                    <div class="chapter-prev chapter-down animated">
                        <a prev-chapter href="/tutorial/view_chapter/82.html"><i class="icon-arrow-left"></i> 2.7 内核模块之中断</a>
                    </div>
                    <div class="chapter-next chapter-down animated">
                        <a next-chapter href="/tutorial/view_chapter/83.html">2.9 内核模块之定时器 <i class="icon-arrow-right"></i></a>
                    </div>
                    
                </div>
                
            </div>
        </div>
        <div class="span3" id="right-side">
            
            <div id="toc-container" class="nano">
            <div id="toc" class="content"></div>
            </div>
        </div>
    </div>
</div>
<div id="para-comments" style="display:none;">
</div>
<style>
#toc {top:140px;}
</style>
<script>
    function viewport()
    {
        var e = window, a = 'inner';
        if ( !( 'innerWidth' in window ) )
        {
            a = 'client';
            e = document.documentElement || document.body;
        }
        return { width : e[ a+'Width' ] , height : e[ a+'Height' ] }
    }
    
    //滚动插件
    /*(function () {
      $.fn.anchorScroll = function (options) {
        var defaults = {
          speed: 1100,
          fx: "jswing",
          offset: 0
        };
        //var version =  "1.0";
        var options = $.extend(defaults, options);
        return $(this).each(function () {
          var element = this;
          $(element).click(function (event) {
            var elementClick = $(element).attr("href").replace(/\./g, '\\.');
            var destination = $(elementClick).offset().top - options.offset;
            $("html,body").animate({
              scrollTop: destination
            }, options.speed, options.fx);
            //Stop links default events
            event.preventDefault();
            return false;
          })
        })
      }
    })(jQuery);
    */
    

    $(function(){
        //实现代码高亮
        window.prettyPrint && prettyPrint();
        
        //増加标题探测
        //$('body').scrollspy({target:'#titles', offset:50});
        
        $.ajax({
            type:'GET',
            dateType:'json',
            url:'/tutorial/get_paragraph_comments_count/109',
            success:function(data){
                //増加气泡评论显示
                $('a.comment_point').each(function(index, el){
                    var id = $(el).attr('rel');
                    var count = id in data?data[id]:0;
                    var item = $('<a href="/tutorial/view_paragraph_comments/109?para=' + id + '" class="para-comments-count animated">'+count+'</a>')
                        .css({position:'absolute', left:'-50px'});
                    $(el).closest('p').prepend(item);
                });
                
                if (data['0']){
                    $('#global-comment-count').text(data['0']);
                }
                //处理pageslide
                $('a.para-comments-count').pageslide({
                    //'href':'#para-comments',
                    iframe:false,
                    direction:'right',
                    width: '400px',
                    onClick: function(e){
                        $('a.para-comments-count').removeClass('active');
                        $(this).addClass('active');
                        //处理toTop
                        reset_totop();
                    },
                    onClose: function(){
                        $('a.para-comments-count').removeClass('active');
                        //处理toTop
                        reset_totop();
                    }
                });
                
            }
        });
        /*
        $('p.tutorial_p').hover(function(e){
            $(this).find('a.para-comments-count').addClass('swing');
        }, function(e){
            $(this).find('a.para-comments-count').removeClass('swing');
        });
        */
        
        $('.chapter-prev, .chapter-next').hover(function(e){
            $(this).animate({opacity:1}, 500);
        }, function(e){
            $(this).animate({opacity:0.5}, 500);;
        });
        
        //増加限制目录区高度的处理
        //$('#titles').height(viewport().height - 160);
        
        //限定pageslide的高度
        //$('#pageslide').height(viewport().height - 160);
        //实现平滑滚动
        //$('#titles a').anchorScroll({offset:50});
        
        function setup_toc(){
            $('#toc').height(viewport().height - $('#toc').offset()['top'] - 40);
            $('#toc').toc({
                'selectors': 'h2,h3', //elements to use as headings
                'highlightOffset': 0, //offset to trigger the next headline
                'offset': 50
            });
        }
        
        setup_toc();
        
        $(window).resize(function(){
        	setup_toc();
        });
        
        
        //増加代码提示
        $('pre, .inline-tag').code_comment();
        
        //处理回到顶部显示
        $('.outter').UItoTop({ easingType: 'easeOutQuart', text:'<i class="icon-arrow-up"></i>回到顶部' });
        
        //处理动态滚动条
        //$("#toc-container").nanoScroller();
        
        //处理左键，右键前后翻页
        $(document).bind('keydown.left', function(){
            var el = $('a[prev-chapter]');
            if (el.length>0){
                el[0].click();
            }
        }).bind('keydown.right', function(){
            var el = $('a[next-chapter]');
            if (el.length>0){
                el[0].click();
            }
        }).bind('keydown.return', function(){
            $('.expander').click();
        }).bind('keydown.c', function(){
            $('a.para-comments-count').click();
        });
        
        function reset_totop(){
            var top = $('#toTop');
            var that = $('.outter');
            var left = $(that).outerWidth() + $(that).offset().left + 2;
            top.offset({left:left, bottom:10});
        }
        
        //处理expander事件，如果点击，则隐藏目录栏
        $('.expander').click({'opened':false}, function(e){
            if (!e.data.opened){
                $('#article').removeClass('span8').addClass('span12');
                $('#right-side').removeClass('span4').hide();
                e.data.opened = true;
                $(this).html('&laquo;');
            }else{
                $('#article').removeClass('span12').addClass('span8');
                $('#right-side').addClass('span4').show();
                e.data.opened = false;
                $(this).html('&raquo;');
            }
            //处理toTop
            reset_totop();
        });
        
    });
</script>



<div class="container">
  <footer class="row">
  
<p>
Uliweb
</p>

  </footer>
</div>
      


<!-- bottomlinks -->
<script>$.ajaxSetup({cache:false, traditional:true});</script>
<script type="text/javascript" src="/static/pageslide/jquery.pageslide.js?ver=2"></script>
<script type="text/javascript" src="/static/toc/toc.js?ver=2"></script>


  </body>
</html>
